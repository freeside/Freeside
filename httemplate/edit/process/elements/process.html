<%doc>

Example:

 include( 'elements/process.html',

   ###
   # required
   ###

  'table' => 'tablename',

   #? 'primary_key' => #required when the dbdef doesn't know...???
   #? 'fields' => []   #""

   ###
   # optional
   ###

   'viewall_dir'  => '', #'search' or 'browse', defaults to 'search'
   'viewall_ext'  => 'html', #'cgi' or 'html', defaults to 'html'
   OR
   'redirect'     => 'view/table.cgi?', # value of primary key is appended
                                        # (string or coderef returning a string)
   OR
   'popup_reload' => 'Momentary success message', #will reload parent window

   'error_redirect' => popurl(2).'edit/table.cgi?', #query string appended

   'edit_ext' => 'html', #defaults to 'html', you might want 'cgi' while the
                         #naming is still inconsistent

   'copy_on_empty'  => [ 'old_field_name', 'another_old_field', ... ],

   'clear_on_error' => [ 'form_field1', 'form_field2', ... ],

                  #pass an arrayref of hashrefs for multiple m2ms or m2names
                  #be certain you incorporate m2m_Common if you see error: param

   'process_m2m' => { 'link_table'   => 'link_table_name',
                      'target_table' => 'target_table_name',
                      #optional (see m2m_Common::process_m2m), if not specified
                      # all CGI params will be passed)
                      'params'       => 
                    },
   'process_m2name' => { 'link_table'   => 'link_table_name',
                         'link_static' => { 'column' => 'value' },
                         'num_col' => 'column', #if column name is different in
                                                #link_table than source_table 
                         'name_col' => 'name_column',
                         'names_list' => [ 'list', 'names' ],
                         
                         'param_style' => 'link_table.value checkboxes',
                         #or#
                         'param_style' => 'name_colN values',


                       },
   'process_o2m' => { 'table' => table_name',
                      'num_col' => 'column', #if column name is different in
                                             #link_table than source_table 
                    },

   #checks CGI params and whatever else before much else runs
   #return an error string or empty for no error
   'precheck_callback' => sub { my( $cgi ) = @_; },

   #supplies arguments to insert() and replace()
   # for use with tables that are FS::option_Common (among other things)
   'args_callback' => sub { my( $cgi, $object ) = @_; },

   'debug' => 1, #turns on debugging output

   #agent virtualization
   'agent_virt'       => 1,
   'agent_null_right' => 'Access Right Name',

 )

</%doc>
%if ( $error ) {
%
%  my $edit_ext = $opt{'edit_ext'} || 'html';
%  my $url = $opt{'error_redirect'} || popurl(2)."$table.$edit_ext";
%  if ( length($cgi->query_string) > 1920 ) { #stupid IE 2083 URL limit
% 
%    my $session = int(rand(4294967296)); #XXX
%    my $pref = new FS::access_user_pref({
%      'usernum'    => $FS::CurrentUser::CurrentUser->usernum,
%      'prefname'   => "redirect$session",
%      'prefvalue'  => $cgi->query_string,
%      'expiration' => time + 3600, #1h?  1m?
%    });
%    my $pref_error = $pref->insert;
%    if ( $pref_error ) {
%      die "FATAL: couldn't even set redirect cookie: $pref_error".
%          " attempting to set redirect$session to ". $cgi->query_string."\n";
%    }
%
<% $cgi->redirect("$url?redirect=$session") %>
%
%  } else {
%
<% $cgi->redirect("$url?". $cgi->query_string ) %>
%
%  } 
%
% #different ways of handling success
%
%} elsif ( $opt{'popup_reload'} ) {

  <% include('/elements/header-popup.html', $opt{'popup_reload'} ) %>

  <SCRIPT TYPE="text/javascript">
    window.top.location.reload();
  </SCRIPT>

  </BODY>
  </HTML>

%} else {
%  
%  $opt{'redirect'} = &{$opt{'redirect'}}($cgi, $new)
%    if ref($opt{'redirect'}) eq 'CODE';
%
%  if ( $opt{'redirect'} ) {
%
<% $cgi->redirect( $opt{'redirect'}. $pkeyvalue ) %>
%
%  } else { 
%
%    my $ext = $opt{'viewall_ext'} || 'html';
%
<% $cgi->redirect( popurl(3). ($opt{viewall_dir}||'search'). "/$table.$ext" ) %>
%
%  }
%
%}
%
<%init>

my $me = 'process.html:';

my(%opt) = @_;

my $curuser = $FS::CurrentUser::CurrentUser;

my $error = '';
if ( $opt{'precheck_callback'} ) {
  $error = &{ $opt{'precheck_callback'} }( $cgi );
}

#false laziness w/edit.html
my $table = $opt{'table'};
my $class = "FS::$table";
my $pkey = dbdef->table($table)->primary_key; #? $opt{'primary_key'} || 
my $fields = $opt{'fields'}
             #|| [ grep { $_ ne $pkey } dbdef->table($table)->columns ];
             || [ fields($table) ];

my $pkeyvalue = $cgi->param($pkey);

my $old = '';
if ( $pkeyvalue ) {
  $old = qsearchs({
    'table'   => $table,
    'hashref' => { $pkey => $pkeyvalue },
    'extra_sql' => ( $opt{'agent_virt'}
                       ? ' AND '. $curuser->agentnums_sql(
                                    'null_right' => $opt{'agent_null_right'}
                                  )
                       : ''
                   ),
  });
}

my %hash =
  map { my @entry = ( $_ => scalar($cgi->param($_)) );
        $opt{'value_callback'} ? ( $_ => &{ $opt{'value_callback'} }( @entry ))
                               : ( @entry )
      } @$fields;

my $new = $class->new( \%hash );

if ($old && exists($opt{'copy_on_empty'})) {
  foreach my $field (@{$opt{'copy_on_empty'}}) {
    $new->set($field, $old->get($field))
      unless scalar($cgi->param($field));
  }
}

if ( $opt{'agent_virt'} ) {
  die "illegal agentnum"
    unless $curuser->agentnums_href->{$new->agentnum}
        or $opt{'agent_null_right'}
           && ! $new->agentnum
           && $curuser->access_right($opt{'agent_null_right'});
}

$error ||= $new->check;

my @args = ();
if ( !$error && $opt{'args_callback'} ) {
  @args = &{ $opt{'args_callback'} }( $cgi, $new );
}

if ( !$error && $opt{'debug'} ) {
  warn "$me updating record in $table table using $class class\n";
  warn Dumper(\%hash);
  warn "with args: \n". Dumper(\@args) if @args;
}

if ( !$error ) {
  if ( $pkeyvalue ) {
    $error = $new->replace($old, @args);
  } else {
    $error = $new->insert(@args);
    $pkeyvalue = $new->getfield($pkey);
  }
}

if ( !$error && $opt{'process_m2m'} ) {

  my @process_m2m = ref($opt{'process_m2m'}) eq 'ARRAY'
                      ? @{ $opt{'process_m2m'} }
                      :  ( $opt{'process_m2m'} );

  foreach my $process_m2m (@process_m2m) {

    $process_m2m->{'params'} ||= scalar($cgi->Vars);

    warn "$me processing m2m:\n". Dumper( %$process_m2m )
      if $opt{'debug'};

    $error = $new->process_m2m( %$process_m2m );
  }

}

if ( !$error && $opt{'process_m2name'} ) {

  my @process_m2name = ref($opt{'process_m2name'}) eq 'ARRAY'
                         ? @{ $opt{'process_m2name'} }
                         :  ( $opt{'process_m2name'} );


  foreach my $process_m2name (@process_m2name) {

    if ( $opt{'debug'} ) {
      warn "$me processing m2name:\n". Dumper( %{ $process_m2name },
                                               'params' => scalar($cgi->Vars),
                                             );
    }

    $error = $new->process_m2name( %{ $process_m2name },
                                   'params' => scalar($cgi->Vars),
                                 );
  }

}

if ( !$error && $opt{'process_o2m'} ) {

  my @process_o2m = ref($opt{'process_o2m'}) eq 'ARRAY'
                         ? @{ $opt{'process_o2m'} }
                         :  ( $opt{'process_o2m'} );


  foreach my $process_o2m (@process_o2m) {

    if ( $opt{'debug'} ) {
      warn "$me processing o2m:\n". Dumper( %{ $process_o2m },
                                               'params' => scalar($cgi->Vars),
                                             );
    }

    $error = $new->process_o2m( %{ $process_o2m },
                                   'params' => scalar($cgi->Vars),
                                 );
  }

}


if ( $error ) {
  $cgi->param('error', $error);
  if ( $opt{'clear_on_error'} && scalar(@{$opt{'clear_on_error'}}) ) {
    foreach my $field (@{$opt{'clear_on_error'}}) {
      $cgi->param($field, '')
    }
  }
}

</%init>
